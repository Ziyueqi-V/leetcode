
class Solution:
    def reachNumber(self, target: int) -> int:
        # 注意一个大方向，那就是无论是正走反走，都是一步，对于结果k是一样的
        # 无论目标方向是在正是负，我们的步数不变，只是每一步的方向统一取反就好了，对最终结果k并无影响，所以此处直接取绝对值，视为同一情况处理
        target = abs(target)
        # 初始化步数为零，注意步数有两个意义，这是根据题目指出的，一是当前已经走了几步，二是上一步走了多远，自然是k个单位，按题意，下一步自然走（k+1）个单位
        k = 0
        # 这个判断其实就是在看离目标还有多远，
        # 大于零就是没走到呗，
        # 等于零时就是刚好走到了，
        # 小于零时就是走过了，
        while target > 0:
            # 既然进入循环了，那么就是没走到，没走到就继续走，
            # 走了一步就更新k的状态
            k += 1
            # 既然走了一步了，那么和目标的距离也就缩短了，缩短了多少，就是上一步的步长k，所以从更新到目标的距离
            target -= k
        # 出了循环说明已经走到了，但是并不是已经走完了，存在走超过了的可能（走没走完要看是不是刚好到终点，反映在数值上就是target刚好为0）
        # 刚好走到重点，那么此时k就是答案
        # 走超了，那就把之前的某些步数反向，走少一点，但是这里有一个要点，就是反向，我们不光失去了原来的距离（假定为A），因为本该走却没走，还反向走了A，那么我们一共损失距离就是2A，一定是偶数
        # 走超了，超了偶数个单位，那么其中某步方向不久好了，总步数丝毫没有增加
        # 走超了，超了奇数单位，一步都不增加只反向某步或者某几步都无法解决，那么勉为其难再走一步
        # 走超了，超了奇数单位，再走一步后，超了偶数个单位长度，前面某不或者某几步反向调整即可解决，此时可以得到答案为k+1 （超了奇数个单位，再走一步超了偶数个，那么再走的一步必定为奇数，也就是（k+1）为奇数，也就是k为偶数）
        # 走超了，超了奇数单位，再走一步后，还是超了奇数个单位，再一步都不走还是无法解决，那么再走一步，此时超出距离必定为偶数了，因为超出距离假定为X，多走的第一步为M，此时共多走X+M+（M+1），这不指定为偶数吗，所以此时也有答案为 k+1+1 （（奇数+(k+2))为偶数，那么k为奇数，这是else后面判断怎么加的条件）
        # 最终实际情况无需额外多走的，都是分析中多走刚好为偶数的（刚好到，多走0步）
        # 最终实际情况需要多走的，
        return k if  target % 2== 0 else k + 1 + k % 2
